<html>
<head>
  <title>polygon.js - offset</title>
  <script type="text/javascript" src="../node_modules/onecolor/one-color-all-debug.js"></script>
  <script type="text/javascript" src="dat.gui.js"></script>
  <script type="text/javascript" src="../node_modules/fc/fc.js"></script>
  <script type="text/javascript" src="../node_modules/vec2/vec2.js"></script>
  <script type="text/javascript" src="../node_modules/segseg/index.js"></script>
  <script type="text/javascript" src="../node_modules/line2/line2.js"></script>
  <script type="text/javascript" src="../polygon.js"></script>
  <style type="text/css">
    body {
      background: #111115
    }
  </style>
</head>
<body>

  <script type="text/javascript">
    var hsl = function(h,s,l) {
      return new one.color.HSL(h, s, l).hex();
    };

    var p = new Polygon([


      Vec2(-100, -100),
      Vec2(100, -100),
      Vec2(200, -200),
      Vec2(100, 0),


      Vec2(300, 0),
      Vec2(350, -100),
      Vec2(350, -200),
      Vec2(275, -300),
      Vec2(600, -300),

      Vec2(400, -200),
      Vec2(400, -150),


      Vec2(600, -100),
      Vec2(500, 200),
      Vec2(300, 100),


      Vec2(100, 200),
      Vec2(-100, 100),
      Vec2(-100, 0)
    ]);


    var renderPoly = function(polygons, angle, dashed, width) {

      var a = Array.isArray(polygons) ? polygons : [polygons];

      a.forEach(function(poly) {
        if (!poly.points.length || !poly.point(0)) {
          return;
        }

        ctx.beginPath();
          ctx.moveTo(poly.point(0).x, poly.point(0).y);
          poly.points.forEach(function(c) {
            ctx.lineTo(c.x, c.y);
          });
        var origWidth = ctx.lineWidth;
        ctx.closePath();
        ctx.lineWidth = width || 1;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.strokeStyle = hsl(angle, .75, .65);
        ctx.stroke();
        ctx.lineWidth = origWidth;

        ctx.strokeStyle =  hsl(angle, 1, .65);
        poly.points.forEach(function(c) {
          ctx.beginPath();
            var orig = ctx.strokeStyle;


            if (c.color) {
              ctx.arc(c.x, c.y, (c.radius || .5), Math.PI*2, false);
              ctx.strokeStyle = c.color;
              ctx.stroke();
            }



          if (c.point && dashed !== false) {
            dashedLine(ctx, c, c.point, 4);
            ctx.stroke();
          }
          ctx.strokeStyle = orig;

        });
      });
    };

    var renderPolyPoints = function(polygon, color, radius) {
      polygon.points.forEach(function(point) {
        ctx.beginPath();
          ctx.arc(point.x, point.y, point.radius || radius || 5, Math.PI*2, false);
          ctx.strokeStyle = color || 'red';
          ctx.stroke();
      });
    };

    var dashedLine = function (ctx, start, end, dashLen) {
      ctx.beginPath();
      if (dashLen == undefined) dashLen = 2;
      ctx.moveTo(start.x, start.y);

      var dX = end.x - start.x;
      var dY = end.y - start.y;
      var dashes = Math.floor(Math.sqrt(dX * dX + dY * dY) / dashLen);
      var dashX = dX / dashes;
      var dashY = dY / dashes;

      var q = 0;
      var sx = start.x;
      var sy = start.y;
      while (q++ < dashes) {
        sx += dashX;
        sy += dashY;
        ctx[q % 2 == 0 ? 'moveTo' : 'lineTo'](sx, sy);
      }
      ctx[q % 2 == 0 ? 'moveTo' : 'lineTo'](sx, sy);
    };



    var config = {
      inner: -200,
      outer: -50,
      step: 10,
      renderPoly: false,
      renderPoints: false,
      simplify: false,
      renderSelfIntersections: true,
      pruneSelfIntersections: false
    };
    try {
      obj = JSON.parse(window.localStorage.getItem('offset-data') || '{}') || {};
      Object.keys(obj).forEach(function(k) {
        config[k] = obj[k];
      });
    } catch (e) {
      throw e;
    }


    var ctx = fc(function() {

      var w = ctx.canvas.width;
      var h = ctx.canvas.height;

      ctx.fillStyle = '#111115';
      ctx.fillRect(0, 0, w, h);

      ctx.save();
        ctx.translate(w/2 - 200, h/2 - 100);
        ctx.scale(1, -1);

        ctx.beginPath()
        ctx.moveTo(-5, -5);
        ctx.lineTo(5, 5);
        ctx.closePath();
        ctx.strokeStyle = "blue"
        ctx.stroke();

        ctx.beginPath()
        ctx.moveTo(-5, 5);
        ctx.lineTo(5, -5);
        ctx.closePath();
        ctx.strokeStyle = "blue"
        ctx.stroke();

        if (0) {
          // TODO: when you bump this up past 200 we start seeing issues
          //       I think we need to cap the ends of really long lines
          //       and completely implement pruneSelfIntersections

          // for (var i=10; i<100; i+=1) {
          //   renderPoly(p.offset(i).simplify().pruneSelfIntersections(), i*.002, false);
          // }

          renderPoly(p.offset(10), .5);
          renderPoly(p.offset(5), .5);
          renderPoly(p.offset(20), .7);

          for (var i = -10; i>-100; i -= 10) {
            var offset = p.offset(i, true);
            var pruned = offset.clone().simplify().pruneSelfIntersections();
            if (pruned.length) {
              pruned.forEach(function(poly, j) {
                renderPoly(poly, i*.001 + j * .0001, false)
              });
            } else {
              renderPoly(offset, i*.001 , false);
            }
          }
        } else {
          // TODO: this breaks at -110 because the first point is invalid
          // TODO: this breaks at 30 because of invalid 'interferes' handling

          for (var i = config.inner; i<config.outer; i += config.step || 10) {
            if (i === 0) { continue; }
            var o = p.offset(i, true);

            config.simplify && o.simplify();
            config.renderPoints && renderPolyPoints(o, 'blue', 1);
            config.renderPoly && renderPoly(o, .3);
            config.renderSelfIntersections && renderPolyPoints(o.selfIntersections());

            if (config.pruneSelfIntersections) {

              var selfi = o.pruneSelfIntersections(function(point) {

                // TODO: not properly handling global interference when
                //       delta is positive - or this implementation is busted.


                var dtoclosest = p.closestPointTo(point).subtract(point, true).length();
                var d = dtoclosest - Math.abs(i);
                var valid = Math.round(d*1000)/1000 === 0;

                if (i > 0 && d >= 0) {
                  valid = true;
                }

                if (valid) {
                  return (i > 0 && !p.containsPoint(point)) || (i<0 && p.containsPoint(point));
                } else {
                  console.error('NOT VALID', i, dtoclosest, d);
                }
              });

              selfi.forEach(function(s, j) {

                // renderPolyPoints(s, 'green', 2);
                // TODO: without this simplify, some polygons have hairs
                renderPoly(s.simplify(), i/100 - j/selfi.length, false);
              });
            }
          }
        }

        renderPoly(p, 0, false, 3);

      ctx.restore();

    }, false);

    var gui = new dat.GUI({ });
    var updateValues = function() {
      console.clear();
      window.localStorage.setItem('offset-data', JSON.stringify(config));
      ctx.dirty();
    };

    gui.add(config, 'inner', -200, 500).onChange(updateValues);
    gui.add(config, 'outer', -200, 500).onChange(updateValues);
    gui.add(config, 'step', 1, 200).onChange(updateValues);
    gui.add(config, 'renderSelfIntersections', false).onChange(updateValues);
    gui.add(config, 'renderPoly', false).onChange(updateValues);
    gui.add(config, 'renderPoints', false).onChange(updateValues);
    gui.add(config, 'simplify', false).onChange(updateValues);
    gui.add(config, 'pruneSelfIntersections', false).onChange(updateValues);




  </script>


</body>
</html>
